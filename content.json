{"meta":{"title":null,"subtitle":null,"description":null,"author":"zyz","url":"http://yoursite.com"},"pages":[{"title":"About 页面","date":"2017-12-18T07:46:34.000Z","updated":"2017-12-18T08:56:17.652Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About 页面 $T(n) = \\Theta(n)$$E=mc^2$"},{"title":"categories","date":"2017-12-08T01:35:08.000Z","updated":"2017-12-15T09:57:44.293Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-08T01:33:46.000Z","updated":"2017-12-15T09:55:11.648Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js 验证文件 file","slug":"js-file-verify","date":"2018-01-08T09:56:00.090Z","updated":"2018-01-13T06:25:39.254Z","comments":true,"path":"2018/01/08/js-file-verify/","link":"","permalink":"http://yoursite.com/2018/01/08/js-file-verify/","excerpt":"","text":"1. js 验证文件 file 合法性 使用js验证input的file合法性。比如宽、高、文件大小、后缀名等。传参使用面向对象的思想。也就是自定义对象，把验证参数都放在一个对象里面。 这里会一步步进行详解最后，会贴出完整的代码。 2. 新建一个html页面和js文件如图，新建两个文件，分别是 index.html 和 file_verify.js 3. 编辑 index.html 页面 效果图如下 代码如下，后面将进行讲解。1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.4.1.min.js\"&gt;&lt;/script&gt; &lt;!-- 验证上传文件的合法性写成单独的js --&gt; &lt;script type=\"text/javascript\" src=\"js/file_verify.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function verifyFile(fileObj) &#123; debugger; var verify = &#123; maxWidth: 100, maxHeight: 100, maxSize: 1024, allowSuffixName: [\"jpg\", \"png\", \"bmp\"], &#125;; //调用js file_verify(obj, verify); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 选择文件：&lt;input type=\"file\" id=\"uploadFile\" onchange=\"verifyFile(this)\" /&gt; &lt;/body&gt;&lt;/html&gt; 3.1 this 、 jQuery 获取 input 对象、 document.getElementById(&quot;uploadFile&quot;) 之间的区别我们需要在 input 标签里面加上 onchange 事件。如：onchange=&quot;verifyFile(this)&quot; 。有时候，你不加 onchange 事件，用 jQuery 进行绑定一个事件或者获取这个 input 对象。 我将会使用下面代码进行验证。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.4.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function verifyFile(fileObj) &#123; debugger; var a = $(\"#uploadFile\"); var b = document.getElementById(\"uploadFile\"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 选择文件：&lt;input type=\"file\" id=\"uploadFile\" onchange=\"verifyFile(this)\" /&gt; &lt;/body&gt;&lt;/html&gt; 从上面代码可以看出，verifyFile 函数将会获取到三个对象，分别是this、jq获取、document.getElementById()。 1). 效果图如下从图中可以看出，fileObj 和 b 是一样的，说明document.getElementById() 和 this 是一样的， 2). this 获取的对象如图 3). jq 获取的对象如图 4). document.getElementById() 获取的对象如图 从上面三种获取input对象的函数可以看出，使用jq获取获取的对象，是一个数组，若想获取和document.getElementById()一样的对象，必须改写为var a = $(&quot;#uploadFile&quot;)[0];。如图 3.2 定义（声明）验证变量从这一小节开始，将进入正文。我们需要 定义（声明）一个验证变量，来存放一些规则，可以使得你选择的文件，是否符合这些规则。如一开始所写的，其中有部分代码如下：12345678910&lt;script type=\"text/javascript\"&gt;function verifyFile(fileObj) &#123; var verify = &#123; maxWidth: 100, maxHeight: 100, maxSize: 1024, allowSuffixName: [\"jpg\", \"png\", \"bmp\"] &#125;;&#125;&lt;/script&gt; verify 验证变量，参数如下： 参数名 类型 必要(Y/N) 描述 maxWidth int N 最大宽度，如果是图片的话 maxHeight int N 最大高度，如果是图片的话 maxSize int N 文件大小，KB即千字节为单位 allowSuffixName String N 允许通过的后缀名格式，都为小写 4. 编辑 file_verify.jsfile_verify.js，里面的函数，完全是根据verify 验证变量来编写的。函数全部自定义。以上面小节的verify为例，来编写file_verify.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 外部调用的方法 * @param &#123;Object&#125; fileObj 要验证的文件对象 * @param &#123;Object&#125; verify 规则参数 */function file_verify(fileObj, verify) &#123; debugger; var v = new VerifyObj(fileObj, verify); var retArr = []; var retFlag = true; var errorMsg = \"\"; for(var i = 0; retFlag; i++) &#123; switch (i)&#123; case 0: retArr = v.hasFile(); break; case 1: retArr = v.suffixByAllow(); break; default: retArr = [false, \"\"]; break; &#125; retFlag = retArr[0]; errorMsg = retArr[1]; &#125; if (errorMsg != \"\") &#123; //清空文件 fileObj.outerHTML = fileObj.outerHTML; alert(errorMsg); &#125;&#125;/** * 自定义验证对象，设置属性和方法 * @param &#123;Object&#125; fileObj 要验证的文件对象 * @param &#123;Object&#125; verify 规则参数 */function VerifyObj(fileObj, verify) &#123; this.fileObj = fileObj; this.verify = verify;&#125;VerifyObj.prototype = &#123; constructor : VerifyObj, //是否有文件 hasFile : function() &#123; debugger; return [this.fileObj.files.length &gt; 0 ? true : false,\"\"]; &#125;, //允许通过的后缀名 suffixByAllow : function() &#123; debugger; var allow = this.verify.allowSuffixName; if (this.isEmpty(allow)) &#123; return [true, \"\"]; &#125; var filename = this.fileObj.files[0].name; var suffix = filename.substr(filename.lastIndexOf(\".\")+1).toLowerCase(); var index = jQuery.inArray(suffix, allow); return index != -1 ? [true,\"\"] : [false,\"文件不合法,暂只支持[\" + allow.join(\"、\") + \"]格式!\"]; &#125;, //是否为空 isEmpty : function(str) &#123; return !isNotEmpty(str); &#125;, //是否不为空 isNotEmpty : function(str) &#123; if(str != undefined &amp;&amp; str != null &amp;&amp; str != '') &#123; return true; &#125; return false; &#125;&#125; 我们自定义一个验证对象VerifyObj，把所有函数都定义在VerifyObj.prototype里面。在file_verify函数里通过new VerifyObj()来创建这个对象。目前，我们在VerifyObj.prototype定义了三个通用的函数：isEmpty、isNotEmpty 和 hasFile。isEmpty : 判断字符串是否为空，true为空，false不为空isNotEmpty : 判断字符串是否不为空，true不为空，false为空hasFile ： 判断是否有文件，true为有文件，false为没有文件 isEmpty和isNotEmpty主要用于判断参数verify里面是否有定义某个属性。比如，1234var verify = &#123; maxWidth: 100, maxHeight: 100&#125;; 我只定义了参数maxWidth和maxHeight，没有定义allowSuffixName。像VerifyObj.prototype里的函数suffixByAllow，函数里面有这句代码var allow = this.verify.allowSuffixName;，它将返回undefined，如果你不做非空判断，那么后面的代码将会抛出异常。 在每一个定义的函数里面，最后都返回一个数组。例如：return index != -1 ? [true,&quot;&quot;] : [false,&quot;文件不合法,暂只支持[&quot; + allow.join(&quot;、&quot;) + &quot;]格式!&quot;];数组第一个元素：true or false。true 表示文件符合当前函数定义的规则，反之不符合。数组第二个元素：文件不合法... 表示为错误信息errorMsg。 4.1 根据verify变量继续自定义函数:验证文件大小在3.2小节，我们定义了验证变量。123456var verify = &#123; maxWidth: 100, maxHeight: 100, maxSize: 1024, allowSuffixName: [\"jpg\", \"png\", \"bmp\"]&#125;; 在4小节，根据验证变量中allowSuffixName参数，在VerifyObj.prototype里定义函数suffixByAllow。那么我们根据size来定制属于它们两个的函数。1234567891011VerifyObj.prototype = &#123; constructor : VerifyObj, //是否有文件 hasFile : function() &#123;...&#125;, //允许通过的后缀名 suffixByAllow : function() &#123;...&#125;, //是否为空 isEmpty : function(str) &#123;...&#125;, //是否不为空 isNotEmpty : function(str) &#123;...&#125;,&#125; 如上代码，我们打算加在isNotEmpty函数后面，注意：isNotEmpty的函数最后要加 逗号&#39;,&#39;。编写完成之后，像下面：123456789101112131415161718VerifyObj.prototype = &#123; ... //是否不为空 isNotEmpty : function(str) &#123;...&#125;, fileSize : function() &#123; debugger; var maxSize = this.verify.maxSize; if (this.isEmpty(maxSize)) &#123; return [true, \"\"]; &#125; //单位为字节，即B；size/1024转换为KB var size = this.fileObj.files[0].size / 1024; if (maxSize &lt; size) &#123; return [false, \"文件大小不能超过\" + maxSize + \"KB\"]; &#125; return [true, \"\"]; &#125;&#125; 当然，这样还不行，你得要触发这个函数，所以你要在file_verify函数加上case语句。如下：12345678910111213141516171819202122function file_verify(fileObj, verify) &#123; ... for(var i = 0; retFlag; i++) &#123; switch (i)&#123; case 0: ... break; case 1: ... break; case 2: retArr = v.fileSize(); break; default: ... break; &#125; retFlag = retArr[0]; errorMsg = retArr[1]; &#125; ...&#125; 4.2 根据verify变量继续自定义函数:验证图片宽高在3.2小节，我们定义了验证变量。123456var verify = &#123; maxWidth: 100, maxHeight: 100, maxSize: 1024, allowSuffixName: [\"jpg\", \"png\", \"bmp\"]&#125;; 在上面一小节，我们定义了fileSize函数。我们打算加在fileSize函数后面，注意：fileSize的函数最后要加 逗号&#39;,&#39;。 验证图片宽高是一个很特殊的情况。因为input传递的，是一个文件对象，不是专门的img图片对象，无法直接获取width和height，只能通过new Image()来创建虚拟的图片对象 编写之后如下(代码太多，省略一些)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556VerifyObj.prototype = &#123; ... //是否不为空 isNotEmpty : function(str) &#123;...&#125;, fileSize : function() &#123;...&#125;, createImgObj : function(callback) &#123; debugger; if(this.isEmpty(this.verify.maxWidth) &amp;&amp; this.isEmpty(this.verify.maxHeight)) &#123; return [true,\"\"]; &#125; //创建虚拟的img图片，只是为了能获取上传图片的宽和高 var img = new Image(); img.onload = function() &#123; debugger; callback(&#123;\"width\":this.width,\"height\":this.height&#125;); &#125;; img.src=this.getObjectURL(); return [true,\"\"]; &#125;, //获得 图片 路径 getObjectURL : function() &#123; var url = null; if(window.createObjectURL != undefined) &#123; // basic url = window.createObjectURL(this.fileObj); &#125; else if(window.URL != undefined) &#123; // mozilla(firefox) url = window.URL.createObjectURL(this.fileObj.files[0]); &#125; else if(window.webkitURL != undefined) &#123; // webkit or chrome url = window.webkitURL.createObjectURL(this.fileObj.files[0]); &#125; return url; &#125;, widthAndHeight : function(imgAttr) &#123; debugger; var width = imgAttr.width; var height = imgAttr.height; var maxWidth = this.verify.maxWidth; var maxHeight = this.verify.maxHeight; //默认宽，高也是符合的 var wflag = true; var hflag = true; if (this.isNotEmpty(maxWidth)) &#123; if(maxWidth != width)&#123; wflag = false; &#125; &#125; if (this.isNotEmpty(maxHeight)) &#123; if(maxHeight != height)&#123; hflag = false; &#125; &#125; if (false == wflag || false == hflag) &#123; return [false, \"图片宽高必须是\"+maxWidth+\"*\"+maxHeight+\"px\"]; &#125; return [false, \"\"]; &#125;&#125; 然后，我们要触发这个函数，所以要在file_verify函数加上case语句。如下：123456789101112131415161718192021222324252627282930313233function file_verify(fileObj, verify) &#123; ... for(var i = 0; retFlag; i++) &#123; switch (i)&#123; case 0: ... break; case 1: ... break; case 2: ... break; case 3: retArr = v.createImgObj(function(imgAttr)&#123; debugger; retArr = v.widthAndHeight(imgAttr); if (retArr[1] != \"\") &#123; //清空文件 fileObj.outerHTML = fileObj.outerHTML; alert(retArr[1]); &#125; &#125;); break; default: ... break; &#125; retFlag = retArr[0]; errorMsg = retArr[1]; &#125; ...&#125; createImgObj函数，主要是创建一个虚拟的img，里面有段代码img.onload = function() {...}，onload是异步加载，最后才执行的，也就是file_verify函数，完全执行完之后，才会触发这个onlaod，所以，这个函数，我们需要用到回调函数callback。widthAndHeight函数，才是正在执行判断图片的宽高是否符合规则的函数。 5. 总结如上所说，你可以自定义更多的规则变量verify，根据verify在VerifyObj.prototype里面定制属于你自己的函数，像size函数一样，当然验证图片宽高，这种是特殊的情况。除了这个之后，目前并没有发现更多特殊的情况。以下贴上完整的代码。 5.1 index.html完整代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 验证上传文件的合法性写成单独的js --&gt; &lt;script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.4.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/file_verify.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; /* * 参数： fileObj 文件对象 * 参数： verify 验证规则对象 * verify : &#123; * maxWidth : 100, --最大宽度 * maxHeight : 100, --最大高度 * allowSuffixName : [\"jpg\", \"png\", \"bmp\"], -- 允许通过的后缀名格式 * notAllowSuffixName : [\"jpg\", \"png\", \"bmp\"], -- 不允许通过的后缀名格式 * isPreview : false, --是否有缩略图， 默认为否 * maxSize : 1024, --允许文件最大大小，单位是KB * &#125; * */ function verifyFile(fileObj) &#123; debugger; var verify = &#123; maxWidth : 100, maxHeight : 100, maxSize : 1000, allowSuffixName : [\"jpg\", \"png\", \"bmp\"], notAllowSuffixName : [\"jpg\", \"png\", \"bmp\"] &#125;; file_verify(fileObj,verify); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 选择文件：&lt;input type=\"file\" id=\"uploadFile\" onchange=\"verifyFile(this)\" /&gt; &lt;/body&gt;&lt;/html&gt; 5.2 file_verify.js完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/** * 外部调用的方法 * @param &#123;Object&#125; fileObj 要验证的文件对象 * @param &#123;Object&#125; verify 规则参数 */function file_verify(fileObj, verify) &#123; debugger; var v = new VerifyObj(fileObj, verify); var retArr = []; var retFlag = true; var errorMsg = \"\"; for(var i = 0; retFlag; i++) &#123; switch (i)&#123; case 0: retArr = v.hasFile(); break; case 1: retArr = v.suffixByAllow(); break; case 2: retArr = v.fileSize(); break; case 3: retArr = v.createImgObj(function(imgAttr)&#123; debugger; retArr = v.widthAndHeight(imgAttr); if (retArr[1] != \"\") &#123; //清空文件 fileObj.outerHTML = fileObj.outerHTML; alert(retArr[1]); &#125; &#125;); break; default: retArr = [false, \"\"]; break; &#125; retFlag = retArr[0]; errorMsg = retArr[1]; &#125; if (errorMsg != \"\") &#123; //清空文件 fileObj.outerHTML = fileObj.outerHTML; alert(errorMsg); &#125;&#125;/** * 自定义验证对象，设置属性和方法 * @param &#123;Object&#125; fileObj 要验证的文件对象 * @param &#123;Object&#125; verify 规则参数 */function VerifyObj(fileObj, verify) &#123; this.fileObj = fileObj; this.verify = verify;&#125;VerifyObj.prototype = &#123; constructor : VerifyObj, hasFile : function() &#123; debugger; return [this.fileObj.files.length &gt; 0 ? true : false,\"\"]; &#125;, suffixByAllow : function() &#123; debugger; var allow = this.verify.allowSuffixName; if (this.isEmpty(allow)) &#123; return [true, \"\"]; &#125; var filename = this.fileObj.files[0].name; var suffix = filename.substr(filename.lastIndexOf(\".\")+1).toLowerCase(); var index = jQuery.inArray(suffix, allow); return index != -1 ? [true,\"\"] : [false,\"文件不合法,暂只支持[\" + allow.join(\"、\") + \"]格式!\"]; &#125;, isEmpty : function(str) &#123; return !this.isNotEmpty(str); &#125;, isNotEmpty : function(str) &#123; if(str != undefined &amp;&amp; str != null &amp;&amp; str != '') &#123; return true; &#125; return false; &#125;, fileSize : function() &#123; debugger; var maxSize = this.verify.maxSize; if (this.isEmpty(maxSize)) &#123; return [true, \"\"]; &#125; //单位为字节，即B；size/1024转换为KB var size = this.fileObj.files[0].size / 1024; if (maxSize &lt; size) &#123; return [false, \"文件大小不能超过\" + maxSize + \"KB\"]; &#125; return [true, \"\"]; &#125;, createImgObj : function(callback) &#123; debugger; if(this.isEmpty(this.verify.maxWidth) &amp;&amp; this.isEmpty(this.verify.maxHeight)) &#123; return [true,\"\"]; &#125; //创建虚拟的img图片，只是为了能获取上传图片的宽和高 var img = new Image(); img.onload = function() &#123; debugger; callback(&#123;\"width\":this.width,\"height\":this.height&#125;); &#125;; img.src=this.getObjectURL(); return [true,\"\"]; &#125;, //获得 图片 路径 getObjectURL : function() &#123; var url = null; if(window.createObjectURL != undefined) &#123; // basic url = window.createObjectURL(this.fileObj); &#125; else if(window.URL != undefined) &#123; // mozilla(firefox) url = window.URL.createObjectURL(this.fileObj.files[0]); &#125; else if(window.webkitURL != undefined) &#123; // webkit or chrome url = window.webkitURL.createObjectURL(this.fileObj.files[0]); &#125; return url; &#125;, widthAndHeight : function(imgAttr) &#123; debugger; var width = imgAttr.width; var height = imgAttr.height; var maxWidth = this.verify.maxWidth; var maxHeight = this.verify.maxHeight; //默认宽，高也是符合的 var wflag = true; var hflag = true; if (this.isNotEmpty(maxWidth)) &#123; if(maxWidth != width)&#123; wflag = false; &#125; &#125; if (this.isNotEmpty(maxHeight)) &#123; if(maxHeight != height)&#123; hflag = false; &#125; &#125; if (false == wflag || false == hflag) &#123; return [false, \"图片宽高必须是\"+maxWidth+\"*\"+maxHeight+\"px\"]; &#125; return [false, \"\"]; &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}]},{"title":"Java 发送 Http 请求","slug":"http-request","date":"2018-01-05T10:57:47.611Z","updated":"2018-01-17T09:45:26.743Z","comments":true,"path":"2018/01/05/http-request/","link":"","permalink":"http://yoursite.com/2018/01/05/http-request/","excerpt":"","text":"Java 发送 Http 请求发送 http 请求。我把它整理成工具类 01/05/2018 新增 发送POST请求 01/17/2018 新增 发送GET请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237import java.io.ByteArrayOutputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.URL;import java.net.URLConnection;import java.util.HashMap;import java.util.Map;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLSession;/** * @author zyz * */public class HttpUtil &#123; /** * 发送Http post请求 * * @param reqData 请求数据 * @param URL 请求url * @return 返回信息 */ public static Map&lt;String, String&gt; doHttpPost(String reqData, String URL) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(3); System.out.println(\"发起的数据:\" + reqData); byte[] xmlData = reqData.getBytes(); InputStream instr = null; try &#123; URL url = new URL(URL); URLConnection urlConn = url.openConnection(); urlConn.setDoOutput(true); urlConn.setDoInput(true); urlConn.setUseCaches(false); urlConn.setRequestProperty(\"Content-length\", String.valueOf(xmlData.length)); //使用Content-Type来表示具体请求中的媒体类型信息。 //请求数据为 json格式，与下面的语句，2选1 contentTypeIsJson(urlConn); //请求数据为 变量1=值1&amp;变量2=值2&amp;... contentTypeIsForm(urlConn); //你还可以定义更多的contentType... DataOutputStream printout = new DataOutputStream( urlConn.getOutputStream()); printout.write(xmlData); printout.flush(); printout.close(); instr = urlConn.getInputStream(); byte[] bis = input2byte(instr); String ResponseString = new String(bis, \"UTF-8\"); if ((ResponseString == null) || (\"\".equals(ResponseString.trim()))) &#123; map.put(\"code\", \"-1\"); map.put(\"msg\", \"返回空\"); System.out.println(\"返回数据为:返回空数据\"); return map; &#125; map.put(\"code\", \"1\"); map.put(\"msg\", \"返回成功\"); map.put(\"respResult\", ResponseString); System.out.println(\"返回数据为:\" + ResponseString); return map; &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(\"code\", \"-1\"); map.put(\"msg\", \"异常：\"+e.getMessage()); return map; &#125; finally &#123; try &#123; instr.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 请求的媒体类型信息为json * 即请求参数为json * @param urlConn */ private static void contentTypeIsJson(URLConnection urlConn) &#123; urlConn.setRequestProperty(\"content-Type\", \"application/json\"); urlConn.setRequestProperty(\"charset\", \"utf-8\"); &#125; /** * 请求的媒体类型信息为 &lt;form encType=””&gt; 中默认的encType * 即请求参数为表单默认的提交数据的格式 * 如：变量1=值1&amp;变量2=值2&amp;... * @param urlConn */ private static void contentTypeIsForm(URLConnection urlConn) &#123; urlConn.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\"); urlConn.setRequestProperty(\"accept\", \"*/*\"); urlConn.setRequestProperty(\"connection\", \"Keep-Alive\"); urlConn.setRequestProperty(\"user-agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\"); &#125; /** * inputStream 转 byte[] * @param inStream * @return * @throws IOException */ public static final byte[] input2byte(InputStream inStream) throws IOException &#123; ByteArrayOutputStream swapStream = new ByteArrayOutputStream(); byte[] buff = new byte[100]; int rc = 0; while ((rc = inStream.read(buff, 0, 100)) &gt; 0) &#123; swapStream.write(buff, 0, rc); &#125; byte[] in2b = swapStream.toByteArray(); return in2b; &#125; /** * 发送Http get请求 * * @param reqData 请求数据 * @param URL 请求url * @return 返回信息 */ public static Map&lt;String, String&gt; doHttpGet(String reqData, String URL) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(3); System.out.println(\"发起的数据:\" + reqData); InputStream instr = null; try &#123; String urlNameString = URL + \"?\" + reqData; URL url = new URL(urlNameString); HostnameVerifier hv = new HostnameVerifier() &#123; @Override public boolean verify(String urlHostName, SSLSession session) &#123; System.out.println(\"Warning: URL Host: \" + urlHostName + \" vs. \" + session.getPeerHost()); return true; &#125; &#125;; trustAllHttpsCertificates(); HttpsURLConnection.setDefaultHostnameVerifier(hv); URLConnection urlConn = url.openConnection(); urlConn.setRequestProperty(\"accept\", \"*/*\"); urlConn.setRequestProperty(\"connection\", \"Keep-Alive\"); urlConn.setRequestProperty(\"user-agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\"); //urlConn.connect(); instr = urlConn.getInputStream(); byte[] bis = input2byte(instr); String ResponseString = new String(bis, \"UTF-8\"); if ((ResponseString == null) || (\"\".equals(ResponseString.trim()))) &#123; map.put(\"code\", \"-1\"); map.put(\"msg\", \"返回空\"); System.out.println(\"返回数据为:返回空数据\"); return map; &#125; map.put(\"code\", \"1\"); map.put(\"msg\", \"返回成功\"); map.put(\"respResult\", ResponseString); System.out.println(\"返回数据为:\" + ResponseString); return map; &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(\"code\", \"-1\"); map.put(\"msg\", \"异常：\"+e.getMessage()); return map; &#125; finally &#123; try &#123; instr.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void trustAllHttpsCertificates() throws Exception &#123; javax.net.ssl.TrustManager[] trustAllCerts = new javax.net.ssl.TrustManager[1]; javax.net.ssl.TrustManager tm = new miTM(); trustAllCerts[0] = tm; javax.net.ssl.SSLContext sc = javax.net.ssl.SSLContext .getInstance(\"SSL\"); sc.init(null, trustAllCerts, null); javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sc .getSocketFactory()); &#125; static class miTM implements javax.net.ssl.TrustManager, javax.net.ssl.X509TrustManager &#123; public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; public boolean isServerTrusted( java.security.cert.X509Certificate[] certs) &#123; return true; &#125; public boolean isClientTrusted( java.security.cert.X509Certificate[] certs) &#123; return true; &#125; public void checkServerTrusted( java.security.cert.X509Certificate[] certs, String authType) throws java.security.cert.CertificateException &#123; return; &#125; public void checkClientTrusted( java.security.cert.X509Certificate[] certs, String authType) throws java.security.cert.CertificateException &#123; return; &#125; &#125; &#125;","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"MD5 加密","slug":"md5-encipher","date":"2018-01-05T05:39:33.694Z","updated":"2018-01-05T10:33:51.817Z","comments":true,"path":"2018/01/05/md5-encipher/","link":"","permalink":"http://yoursite.com/2018/01/05/md5-encipher/","excerpt":"","text":"MD5 加密 网上md5加密各式各样的，现在把自己用的这一份整理处理吧。目前只有加密，没有解密，以后如果有用到其它的，就再新增吧。 MD5加密 -&gt; 32位密文 上代码 1. MD5加密 -&gt; 32位密文 可用&nbsp;&nbsp;toUpperCase() 转成大写可用&nbsp;&nbsp;toLowerCase() 转成小写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * MD5加密类 */public class MD5Utils &#123; /** * Used building output as Hex */ private static final char[] DIGITS = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; /** * 对字符串进行MD5加密 * @param text 明文 * @return 密文 */ public static String md5(String text) &#123; MessageDigest msgDigest = null; try &#123; msgDigest = MessageDigest.getInstance(\"MD5\"); &#125; catch (NoSuchAlgorithmException e) &#123; throw new IllegalStateException(\"System doesn't support MD5 algorithm.\"); &#125; try &#123; // 使用utf-8进行编码 msgDigest.update(text.getBytes(\"UTF-8\")); &#125; catch (UnsupportedEncodingException e) &#123; throw new IllegalStateException(\"System doesn't support your EncodingException.\"); &#125; byte[] bytes = msgDigest.digest(); String md5Str = new String(encodeHex(bytes)); return md5Str; &#125; public static char[] encodeHex(byte[] data) &#123; int l = data.length; char[] out = new char[l &lt;&lt; 1]; // two characters form the hex value. for (int i = 0, j = 0; i &lt; l; i++) &#123; out[j++] = DIGITS[(0xF0 &amp; data[i]) &gt;&gt;&gt; 4]; out[j++] = DIGITS[0x0F &amp; data[i]]; &#125; return out; &#125;&#125;","categories":[],"tags":[{"name":"MD5","slug":"MD5","permalink":"http://yoursite.com/tags/MD5/"}]},{"title":"欢迎使用 Cmd Markdown 编辑阅读器","slug":"example","date":"2017-12-18T03:32:50.457Z","updated":"2017-12-18T07:44:14.092Z","comments":true,"path":"2017/12/18/example/","link":"","permalink":"http://yoursite.com/2017/12/18/example/","excerpt":"","text":"欢迎使用 Cmd Markdown 编辑阅读器 $T(n) = \\Theta(n)$$E=mc^2$我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） cmd-markdown-logo 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 tool-editor 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： tool-manager 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 tool-manager 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： file-list 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","categories":[],"tags":[{"name":"Cmd","slug":"Cmd","permalink":"http://yoursite.com/tags/Cmd/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]}